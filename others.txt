// index.js
require("dotenv").config();
const express = require("express");
const mongoose = require("mongoose");
const authRoutes = require("./routes/authRoutes");
const customerRoutes = require("./routes/customerRoutes");
const loanRoutes = require("./routes/loanRoutes");
const summaryRoutes = require("./routes/summaryRoutes");
const repaymentRoutes = require("./routes/repaymentRoutes");
const { verifyToken } = require("./middleware/authMiddleware");

const app = express();

app.use(express.json());

// Routes
app.use("/api/auth", authRoutes);
app.use("/api/customers", verifyToken, customerRoutes);
app.use("/api/loans", verifyToken, loanRoutes);
app.use("/api/repayments", verifyToken, repaymentRoutes);
app.use("/api", verifyToken, summaryRoutes);

// DB Connection
mongoose
  .connect(process.env.MONGO_URI)
  .then(() => {
    app.listen(process.env.PORT || 5000, () => {
      console.log("Server running on port 5000");
    });
  })
  .catch((err) => console.error("DB Connection Error:", err));

// .gitignore
node_modules/
.env

// Directory structure
// - models/
//   - User.js
//   - Customer.js
//   - Loan.js
//   - Repayment.js
// - controllers/
//   - authController.js
//   - customerController.js
//   - loanController.js
//   - repaymentController.js
//   - summaryController.js
// - routes/
//   - authRoutes.js
//   - customerRoutes.js
//   - loanRoutes.js
//   - repaymentRoutes.js
//   - summaryRoutes.js
// - middleware/
//   - authMiddleware.js
// - utils/
//   - validators.js
//   - dateUtils.js
// .env
// index.js
// package.json
// README.md


// index.js
require("dotenv").config();
const express = require("express");
const mongoose = require("mongoose");
const authRoutes = require("./routes/authRoutes");
const customerRoutes = require("./routes/customerRoutes");
const loanRoutes = require("./routes/loanRoutes");
const summaryRoutes = require("./routes/summaryRoutes");
const repaymentRoutes = require("./routes/repaymentRoutes");
const { verifyToken } = require("./middleware/authMiddleware");

const app = express();

app.use(express.json());

// Routes
app.use("/api/auth", authRoutes);
app.use("/api/customers", verifyToken, customerRoutes);
app.use("/api/loans", verifyToken, loanRoutes);
app.use("/api/repayments", verifyToken, repaymentRoutes);
app.use("/api", verifyToken, summaryRoutes);

// DB Connection
mongoose
  .connect(process.env.MONGO_URI)
  .then(() => {
    app.listen(process.env.PORT || 5000, () => {
      console.log("Server running on port 5000");
    });
  })
  .catch((err) => console.error("DB Connection Error:", err));

// .gitignore
node_modules/
.env

// Directory structure
// - models/
//   - User.js
// - controllers/
//   - authController.js
// - routes/
//   - authRoutes.js
// - middleware/
//   - authMiddleware.js

// models/User.js
const mongoose = require("mongoose");
const validator = require("validator");

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    validate: [validator.isEmail, "Invalid Email"]
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  }
}, { timestamps: true });

module.exports = mongoose.model("User", userSchema);

// controllers/authController.js
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const User = require("../models/User");

const generateToken = (id) => jwt.sign({ id }, process.env.JWT_SECRET, { expiresIn: "7d" });

exports.register = async (req, res) => {
  const { email, password } = req.body;
  try {
    const exists = await User.findOne({ email });
    if (exists) return res.status(400).json({ message: "Email already exists" });

    const hashedPassword = await bcrypt.hash(password, 10);
    const user = await User.create({ email, password: hashedPassword });
    const token = generateToken(user._id);

    res.status(201).json({ token });
  } catch (err) {
    res.status(500).json({ message: "Registration failed", error: err.message });
  }
};

exports.login = async (req, res) => {
  const { email, password } = req.body;
  try {
    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Invalid credentials" });

    const match = await bcrypt.compare(password, user.password);
    if (!match) return res.status(400).json({ message: "Invalid credentials" });

    const token = generateToken(user._id);
    res.status(200).json({ token });
  } catch (err) {
    res.status(500).json({ message: "Login failed", error: err.message });
  }
};

// routes/authRoutes.js
const express = require("express");
const { register, login } = require("../controllers/authController");
const router = express.Router();

router.post("/register", register);
router.post("/login", login);

module.exports = router;

// middleware/authMiddleware.js
const jwt = require("jsonwebtoken");

exports.verifyToken = (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  const token = authHeader.split(" ")[1];
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (err) {
    res.status(401).json({ message: "Invalid token" });
  }
};


// index.js
require("dotenv").config();
const express = require("express");
const mongoose = require("mongoose");
const authRoutes = require("./routes/authRoutes");
const customerRoutes = require("./routes/customerRoutes");
const loanRoutes = require("./routes/loanRoutes");
const summaryRoutes = require("./routes/summaryRoutes");
const repaymentRoutes = require("./routes/repaymentRoutes");
const { verifyToken } = require("./middleware/authMiddleware");

const app = express();

app.use(express.json());

// Routes
app.use("/api/auth", authRoutes);
app.use("/api/customers", verifyToken, customerRoutes);
app.use("/api/loans", verifyToken, loanRoutes);
app.use("/api/repayments", verifyToken, repaymentRoutes);
app.use("/api", verifyToken, summaryRoutes);

// DB Connection
mongoose
  .connect(process.env.MONGO_URI)
  .then(() => {
    app.listen(process.env.PORT || 5000, () => {
      console.log("Server running on port 5000");
    });
  })
  .catch((err) => console.error("DB Connection Error:", err));

// .gitignore
node_modules/
.env

// Directory structure
// - models/
//   - User.js
//   - Customer.js
// - controllers/
//   - authController.js
//   - customerController.js
// - routes/
//   - authRoutes.js
//   - customerRoutes.js
// - middleware/
//   - authMiddleware.js

// models/User.js
const mongoose = require("mongoose");
const validator = require("validator");

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    validate: [validator.isEmail, "Invalid Email"]
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  }
}, { timestamps: true });

module.exports = mongoose.model("User", userSchema);

// models/Customer.js
const mongoose = require("mongoose");

const customerSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true },
  name: { type: String, required: true },
  phone: { type: String, required: true },
  address: { type: String },
  trustScore: { type: Number, min: 0, max: 10, default: 5 },
  creditLimit: { type: Number, default: 0 }
}, { timestamps: true });

module.exports = mongoose.model("Customer", customerSchema);

// controllers/authController.js
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const User = require("../models/User");

const generateToken = (id) => jwt.sign({ id }, process.env.JWT_SECRET, { expiresIn: "7d" });

exports.register = async (req, res) => {
  const { email, password } = req.body;
  try {
    const exists = await User.findOne({ email });
    if (exists) return res.status(400).json({ message: "Email already exists" });

    const hashedPassword = await bcrypt.hash(password, 10);
    const user = await User.create({ email, password: hashedPassword });
    const token = generateToken(user._id);

    res.status(201).json({ token });
  } catch (err) {
    res.status(500).json({ message: "Registration failed", error: err.message });
  }
};

exports.login = async (req, res) => {
  const { email, password } = req.body;
  try {
    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Invalid credentials" });

    const match = await bcrypt.compare(password, user.password);
    if (!match) return res.status(400).json({ message: "Invalid credentials" });

    const token = generateToken(user._id);
    res.status(200).json({ token });
  } catch (err) {
    res.status(500).json({ message: "Login failed", error: err.message });
  }
};

// controllers/customerController.js
const Customer = require("../models/Customer");

exports.createCustomer = async (req, res) => {
  const { name, phone, address, trustScore, creditLimit } = req.body;
  try {
    const customer = await Customer.create({
      userId: req.user.id,
      name,
      phone,
      address,
      trustScore,
      creditLimit
    });
    res.status(201).json(customer);
  } catch (err) {
    res.status(500).json({ message: "Customer creation failed", error: err.message });
  }
};

exports.getCustomers = async (req, res) => {
  try {
    const customers = await Customer.find({ userId: req.user.id });
    res.status(200).json(customers);
  } catch (err) {
    res.status(500).json({ message: "Fetching customers failed", error: err.message });
  }
};

exports.updateCustomer = async (req, res) => {
  try {
    const customer = await Customer.findOneAndUpdate(
      { _id: req.params.id, userId: req.user.id },
      req.body,
      { new: true }
    );
    if (!customer) return res.status(404).json({ message: "Customer not found" });
    res.status(200).json(customer);
  } catch (err) {
    res.status(500).json({ message: "Update failed", error: err.message });
  }
};

exports.deleteCustomer = async (req, res) => {
  try {
    const customer = await Customer.findOneAndDelete({ _id: req.params.id, userId: req.user.id });
    if (!customer) return res.status(404).json({ message: "Customer not found" });
    res.status(200).json({ message: "Customer deleted" });
  } catch (err) {
    res.status(500).json({ message: "Deletion failed", error: err.message });
  }
};

// routes/customerRoutes.js
const express = require("express");
const {
  createCustomer,
  getCustomers,
  updateCustomer,
  deleteCustomer
} = require("../controllers/customerController");
const router = express.Router();

router.post("/", createCustomer);
router.get("/", getCustomers);
router.put("/:id", updateCustomer);
router.delete("/:id", deleteCustomer);

module.exports = router;

// middleware/authMiddleware.js
const jwt = require("jsonwebtoken");

exports.verifyToken = (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  const token = authHeader.split(" ")[1];
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (err) {
    res.status(401).json({ message: "Invalid token" });
  }
};


// models/Loan.js
const mongoose = require("mongoose");

const loanSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true },
  customerId: { type: mongoose.Schema.Types.ObjectId, ref: "Customer", required: true },
  description: { type: String },
  loanAmount: { type: Number, required: true },
  issueDate: { type: Date, required: true },
  dueDate: { type: Date, required: true },
  frequency: { type: String, enum: ["bi-weekly", "monthly"], required: true },
  interestPercent: { type: Number, default: 0 },
  graceDays: { type: Number, default: 0 },
  status: { type: String, enum: ["pending", "paid", "overdue"], default: "pending" },
  balance: { type: Number, required: true }
}, { timestamps: true });

module.exports = mongoose.model("Loan", loanSchema);

// controllers/loanController.js
const Loan = require("../models/Loan");
const moment = require("moment");

exports.createLoan = async (req, res) => {
  const { customerId, description, loanAmount, issueDate, dueDate, frequency, interestPercent, graceDays } = req.body;
  try {
    const loan = await Loan.create({
      userId: req.user.id,
      customerId,
      description,
      loanAmount,
      issueDate,
      dueDate,
      frequency,
      interestPercent,
      graceDays,
      balance: loanAmount
    });
    res.status(201).json(loan);
  } catch (err) {
    res.status(500).json({ message: "Loan creation failed", error: err.message });
  }
};

exports.getLoans = async (req, res) => {
  const { status } = req.query;
  try {
    const query = { userId: req.user.id };
    if (status) query.status = status;
    const loans = await Loan.find(query).populate("customerId", "name phone");
    res.status(200).json(loans);
  } catch (err) {
    res.status(500).json({ message: "Fetching loans failed", error: err.message });
  }
};

// routes/loanRoutes.js
const express = require("express");
const { createLoan, getLoans } = require("../controllers/loanController");
const router = express.Router();

router.post("/", createLoan);
router.get("/", getLoans);

module.exports = router;


// models/Repayment.js
const mongoose = require("mongoose");

const repaymentSchema = new mongoose.Schema({
  loanId: { type: mongoose.Schema.Types.ObjectId, ref: "Loan", required: true },
  amount: { type: Number, required: true },
  date: { type: Date, required: true }
}, { timestamps: true });

module.exports = mongoose.model("Repayment", repaymentSchema);

// controllers/repaymentController.js
const Loan = require("../models/Loan");
const Repayment = require("../models/Repayment");

exports.addRepayment = async (req, res) => {
  const { loanId, amount, date } = req.body;
  try {
    const loan = await Loan.findById(loanId);
    if (!loan || String(loan.userId) !== req.user.id) {
      return res.status(404).json({ message: "Loan not found or unauthorized" });
    }

    const repayment = await Repayment.create({ loanId, amount, date });

    loan.balance -= amount;
    if (loan.balance <= 0) {
      loan.status = "paid";
      loan.balance = 0;
    }
    await loan.save();

    res.status(201).json({ repayment, updatedLoan: loan });
  } catch (err) {
    res.status(500).json({ message: "Repayment failed", error: err.message });
  }
};

// routes/repaymentRoutes.js
const express = require("express");
const { addRepayment } = require("../controllers/repaymentController");
const router = express.Router();

router.post("/", addRepayment);

module.exports = router;


// controllers/summaryController.js
const Loan = require("../models/Loan");
const Repayment = require("../models/Repayment");
const moment = require("moment");

exports.getSummary = async (req, res) => {
  try {
    const loans = await Loan.find({ userId: req.user.id });
    const repayments = await Repayment.find({ loanId: { $in: loans.map(l => l._id) } });

    const totalLoaned = loans.reduce((sum, loan) => sum + loan.loanAmount, 0);
    const totalCollected = repayments.reduce((sum, r) => sum + r.amount, 0);
    const overdueAmount = loans.filter(l => l.status === "overdue").reduce((sum, l) => sum + l.balance, 0);

    const loanRepayTimes = loans.map(loan => {
      const related = repayments.filter(r => String(r.loanId) === String(loan._id));
      if (!related.length) return null;
      const first = moment(loan.issueDate);
      const last = moment(related[related.length - 1].date);
      return last.diff(first, "days");
    }).filter(Boolean);

    const avgRepaymentTime = loanRepayTimes.length ?
      (loanRepayTimes.reduce((a, b) => a + b, 0) / loanRepayTimes.length).toFixed(2) : 0;

    res.json({ totalLoaned, totalCollected, overdueAmount, avgRepaymentTime });
  } catch (err) {
    res.status(500).json({ message: "Summary failed", error: err.message });
  }
};

exports.getOverdue = async (req, res) => {
  try {
    const today = moment();
    const loans = await Loan.find({ userId: req.user.id }).populate("customerId");

    const overdue = loans.filter(loan => {
      const dueDate = moment(loan.dueDate).add(loan.graceDays || 0, "days");
      if (loan.status !== "paid" && dueDate.isBefore(today)) {
        loan.status = "overdue";
        loan.save();
        return true;
      }
      return false;
    });

    res.json(overdue);
  } catch (err) {
    res.status(500).json({ message: "Overdue check failed", error: err.message });
  }
};

// routes/summaryRoutes.js
const express = require("express");
const { getSummary, getOverdue } = require("../controllers/summaryController");
const router = express.Router();

router.get("/summary", getSummary);
router.get("/overdue", getOverdue);

module.exports = router;


// Bonus Feature: PDF Receipt Generation for Repayments

// Install required: npm install pdfkit

// utils/pdfGenerator.js
const PDFDocument = require("pdfkit");
const fs = require("fs");

exports.generateReceiptPDF = (repayment, loan, customer, callback) => {
  const doc = new PDFDocument();
  const filename = `receipt_${repayment._id}.pdf`;
  const filepath = `./receipts/${filename}`;

  if (!fs.existsSync("./receipts")) fs.mkdirSync("./receipts");

  doc.pipe(fs.createWriteStream(filepath));

  doc.fontSize(20).text("CrediKhaata Repayment Receipt", { align: "center" });
  doc.moveDown();

  doc.fontSize(12).text(`Receipt ID: ${repayment._id}`);
  doc.text(`Date: ${new Date(repayment.date).toDateString()}`);
  doc.text(`Customer: ${customer.name}`);
  doc.text(`Phone: ${customer.phone}`);
  doc.text(`Loan Description: ${loan.description}`);
  doc.text(`Amount Paid: ₹${repayment.amount}`);
  doc.text(`Remaining Balance: ₹${loan.balance}`);

  doc.end();

  doc.on("finish", () => callback(filepath));
};

// controllers/repaymentController.js (update addRepayment)
const { generateReceiptPDF } = require("../utils/pdfGenerator");
const Customer = require("../models/Customer");

exports.addRepayment = async (req, res) => {
  const { loanId, amount, date } = req.body;
  try {
    const loan = await Loan.findById(loanId);
    if (!loan || String(loan.userId) !== req.user.id) {
      return res.status(404).json({ message: "Loan not found or unauthorized" });
    }

    const repayment = await Repayment.create({ loanId, amount, date });
    loan.balance -= amount;
    if (loan.balance <= 0) {
      loan.status = "paid";
      loan.balance = 0;
    }
    await loan.save();

    const customer = await Customer.findById(loan.customerId);

    generateReceiptPDF(repayment, loan, customer, (filePath) => {
      res.status(201).json({ repayment, updatedLoan: loan, receipt: filePath });
    });
  } catch (err) {
    res.status(500).json({ message: "Repayment failed", error: err.message });
  }
};


// Bonus Feature: SMS/WhatsApp Reminder (Mocked)

// utils/notifier.js
exports.sendReminder = (customer, loan) => {
  const message = `Reminder: Dear ${customer.name}, your loan of ₹${loan.loanAmount} is due on ${new Date(loan.dueDate).toDateString()}. Please pay on time. - CrediKhaata`;
  console.log(`[Mock SMS] Sent to ${customer.phone}: ${message}`);
  // Integration with actual SMS APIs like Twilio, MSG91, etc. can be added here
};

// controllers/reminderController.js
const Customer = require("../models/Customer");
const Loan = require("../models/Loan");
const { sendReminder } = require("../utils/notifier");
const moment = require("moment");

exports.sendDueReminders = async (req, res) => {
  try {
    const today = moment();
    const loans = await Loan.find({ userId: req.user.id }).populate("customerId");

    const dueSoon = loans.filter(loan => {
      const dueDate = moment(loan.dueDate).add(loan.graceDays || 0, "days");
      return loan.status !== "paid" && dueDate.diff(today, "days") <= 3;
    });

    dueSoon.forEach(loan => {
      sendReminder(loan.customerId, loan);
    });

    res.json({ message: `Reminders sent to ${dueSoon.length} customers` });
  } catch (err) {
    res.status(500).json({ message: "Failed to send reminders", error: err.message });
  }
};

// routes/reminderRoutes.js
const express = require("express");
const { sendDueReminders } = require("../controllers/reminderController");
const router = express.Router();

router.get("/send", sendDueReminders);

module.exports = router;


// Bonus Feature: Webhook for Repayment Notification

// controllers/webhookController.js
exports.repaymentWebhook = async (req, res) => {
  try {
    const { loanId, repaymentId, amount, date } = req.body;
    // Log or forward this information to a third-party service
    console.log("[Webhook Triggered]", {
      loanId,
      repaymentId,
      amount,
      date
    });
    // You can also store these logs or forward via axios/fetch to an external URL
    res.status(200).json({ message: "Webhook received" });
  } catch (err) {
    res.status(500).json({ message: "Webhook processing failed", error: err.message });
  }
};

// routes/webhookRoutes.js
const express = require("express");
const { repaymentWebhook } = require("../controllers/webhookController");
const router = express.Router();

router.post("/repayment", repaymentWebhook);

module.exports = router;

// In your main index.js or app.js (ensure this is added):
// const webhookRoutes = require("./routes/webhookRoutes");
// app.use("/api/webhooks", webhookRoutes);

// Modify repaymentController.js to trigger webhook
const axios = require("axios");

// Inside addRepayment (after saving repayment):
await axios.post("http://localhost:5000/api/webhooks/repayment", {
  loanId: loan._id,
  repaymentId: repayment._id,
  amount: repayment.amount,
  date: repayment.date
});
